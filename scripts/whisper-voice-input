#!/usr/bin/env python3
"""
Whisper Voice Input Script
Records audio and transcribes it using OpenAI Whisper API or local Whisper server
Then types the recognized text into the active window
"""

import os
import sys
import tempfile
import subprocess
import json
import signal
import time
from pathlib import Path

try:
    import requests
except ImportError:
    print("ERROR: python3-requests is not installed", file=sys.stderr)
    sys.exit(1)


# Exit codes
EXIT_SUCCESS = 0
EXIT_CONFIG_ERROR = 1
EXIT_RECORDING_ERROR = 2
EXIT_TRANSCRIPTION_ERROR = 3
EXIT_CANCELLED = 4
EXIT_TIMEOUT = 5


def record_audio_user_controlled(max_duration=300, output_file="/tmp/voice-input.ogg"):
    """
    Record audio using ffmpeg until SIGTERM is received or max duration reached.
    Records to OGG/Opus format - streaming format that doesn't require finalization,
    so files are valid even if recording is interrupted abruptly.
    Returns tuple: (success: bool, reached_max: bool)
    """
    ffmpeg_process = None

    def signal_handler(signum, frame):
        # User stopped recording - kill ffmpeg and continue
        if ffmpeg_process:
            ffmpeg_process.terminate()
        raise InterruptedError("Recording stopped by user")

    # Set up signal handler for SIGTERM
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # Use PulseAudio default source with maximum duration
        # Record to OGG/Opus format - streaming format that doesn't require
        # finalization (no moov atom like M4A), so files are always valid
        cmd = [
            'ffmpeg',
            '-f', 'pulse',
            '-i', 'default',
            '-t', str(max_duration),
            '-c:a', 'libopus',
            '-b:a', '32k',  # 32kbps is sufficient for speech
            '-ar', '16000',
            '-ac', '1',
            '-y',  # Overwrite output file
            output_file
        ]

        print(f"Recording (max {max_duration} seconds)...", file=sys.stderr)
        ffmpeg_process = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

        # Wait for ffmpeg to complete or be terminated
        returncode = ffmpeg_process.wait()

        # Check if ffmpeg completed naturally (reached max duration)
        if returncode == 0:
            # Check file size to determine if we actually recorded something
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                print(f"Recording reached maximum duration ({max_duration}s)", file=sys.stderr)
                return (True, True)  # Success, reached max
            else:
                print("ERROR: No audio recorded", file=sys.stderr)
                return (False, False)
        else:
            print(f"ERROR: ffmpeg failed with code {returncode}", file=sys.stderr)
            return (False, False)

    except InterruptedError:
        # User stopped recording via SIGTERM - this is normal
        # Wait for ffmpeg to finish writing
        if ffmpeg_process:
            try:
                ffmpeg_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                ffmpeg_process.kill()

        # Check if file was created and has content
        if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
            print("Recording stopped by user", file=sys.stderr)
            return (True, False)  # Success, user stopped
        else:
            print("ERROR: No audio recorded", file=sys.stderr)
            return (False, False)

    except Exception as e:
        print(f"ERROR: Recording failed: {e}", file=sys.stderr)
        if ffmpeg_process:
            try:
                ffmpeg_process.kill()
            except:
                pass
        return (False, False)


def transcribe_openai(audio_file, api_key, language="auto", model="whisper-1"):
    """
    Transcribe audio using OpenAI Whisper API
    """
    if not api_key:
        print("ERROR: OPENAI_API_KEY is not set", file=sys.stderr)
        return None

    try:
        url = "https://api.openai.com/v1/audio/transcriptions"
        headers = {
            "Authorization": f"Bearer {api_key}"
        }

        # Check file size for debugging
        file_size = os.path.getsize(audio_file)
        print(f"Audio file size: {file_size} bytes", file=sys.stderr)

        with open(audio_file, 'rb') as f:
            files = {
                'file': (os.path.basename(audio_file), f, 'audio/ogg'),
                'model': (None, model)
            }

            if language != "auto":
                files['language'] = (None, language)

            print(f"Sending request to OpenAI API (model: {model})...", file=sys.stderr)
            start_time = time.time()
            # Timeout: 10 sec for connection, 30 sec for server response
            response = requests.post(url, headers=headers, files=files, timeout=(10, 30))
            elapsed = time.time() - start_time
            print(f"OpenAI response received in {elapsed:.1f}s", file=sys.stderr)

        if response.status_code == 200:
            result = response.json()
            return result.get('text', '').strip()
        elif response.status_code == 429:
            print(f"ERROR: OpenAI API rate limit exceeded. Please wait and try again.", file=sys.stderr)
            return None
        elif response.status_code == 401:
            print(f"ERROR: OpenAI API key is invalid or expired.", file=sys.stderr)
            return None
        elif response.status_code == 400:
            print(f"ERROR: OpenAI API bad request: {response.text}", file=sys.stderr)
            return None
        else:
            print(f"ERROR: OpenAI API error: {response.status_code} {response.text}", file=sys.stderr)
            return None

    except requests.exceptions.Timeout:
        print("ERROR: OpenAI server did not respond in time (30 sec limit). The server may be overloaded.", file=sys.stderr)
        return None
    except requests.exceptions.ConnectionError:
        print("ERROR: Cannot connect to OpenAI API. Check your internet connection.", file=sys.stderr)
        return None
    except Exception as e:
        print(f"ERROR: OpenAI transcription failed: {e}", file=sys.stderr)
        return None


def transcribe_local(audio_file, server_url, language="auto"):
    """
    Transcribe audio using local Whisper server (e.g., faster-whisper-server)
    """
    try:
        # Check file size for debugging
        file_size = os.path.getsize(audio_file)
        print(f"Audio file size: {file_size} bytes", file=sys.stderr)

        with open(audio_file, 'rb') as f:
            files = {
                'audio_file': (os.path.basename(audio_file), f, 'audio/ogg')
            }

            data = {}
            if language != "auto":
                data['language'] = language

            print(f"Sending to local Whisper server at {server_url}...", file=sys.stderr)
            start_time = time.time()
            # Timeout: 10 sec for connection, 30 sec for server response
            response = requests.post(server_url, files=files, data=data, timeout=(10, 30))
            elapsed = time.time() - start_time
            print(f"Local server response received in {elapsed:.1f}s", file=sys.stderr)

        if response.status_code == 200:
            result = response.json()
            # Handle different response formats from various Whisper servers
            if 'text' in result:
                return result['text'].strip()
            elif 'transcription' in result:
                return result['transcription'].strip()
            elif 'results' in result and len(result['results']) > 0:
                return result['results'][0].get('transcript', '').strip()
            else:
                print(f"ERROR: Unexpected response format: {result}", file=sys.stderr)
                return None
        else:
            print(f"ERROR: Local server error: {response.status_code} {response.text}", file=sys.stderr)
            return None

    except requests.exceptions.Timeout:
        print(f"ERROR: Local Whisper server did not respond in time (30 sec limit).", file=sys.stderr)
        return None
    except requests.exceptions.ConnectionError:
        print(f"ERROR: Cannot connect to local Whisper server at {server_url}", file=sys.stderr)
        print("Make sure the server is running", file=sys.stderr)
        return None
    except Exception as e:
        print(f"ERROR: Local transcription failed: {e}", file=sys.stderr)
        return None


def get_active_window():
    """
    Get the active window ID using xdotool
    Returns window ID as string, or None on error
    """
    try:
        result = subprocess.run(
            ['xdotool', 'getactivewindow'],
            capture_output=True,
            text=True,
            timeout=2
        )

        if result.returncode == 0:
            return result.stdout.strip()
        else:
            print(f"ERROR: Failed to get active window: {result.stderr}", file=sys.stderr)
            return None

    except Exception as e:
        print(f"ERROR: Window tracking failed: {e}", file=sys.stderr)
        return None


def copy_to_clipboard(text):
    """
    Copy text to clipboard using xclip
    Returns True on success, False on failure
    """
    try:
        result = subprocess.run(
            ['xclip', '-selection', 'clipboard'],
            input=text.encode(),
            capture_output=True,
            timeout=5
        )

        if result.returncode == 0:
            return True
        else:
            print(f"ERROR: Failed to copy to clipboard: {result.stderr}", file=sys.stderr)
            return False

    except FileNotFoundError:
        print("ERROR: xclip is not installed", file=sys.stderr)
        return False
    except Exception as e:
        print(f"ERROR: Clipboard copy failed: {e}", file=sys.stderr)
        return False


def paste_text(text, window_id=None):
    """
    Paste text using CLIPBOARD + PRIMARY + Shift+Insert.
    Fast method that works in most apps including terminals.

    We copy to both selections because:
    - CLIPBOARD: used by most GUI apps with Shift+Insert
    - PRIMARY: used by terminals with Shift+Insert (they treat it like middle-click)

    Args:
        text: Text to paste
        window_id: Optional window ID to focus before pasting

    Returns:
        True on success, False on failure
    """
    if not text:
        return False

    try:
        # Step 1a: Copy text to CLIPBOARD selection using xclip
        result = subprocess.run(
            ['xclip', '-selection', 'clipboard', '-i'],
            input=text.encode(),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=5
        )

        if result.returncode != 0:
            print("ERROR: Failed to copy to CLIPBOARD selection", file=sys.stderr)
            return False

        # Step 1b: Also copy to PRIMARY selection for terminals
        # Terminals often treat Shift+Insert as paste from PRIMARY, not CLIPBOARD
        subprocess.run(
            ['xclip', '-selection', 'primary', '-i'],
            input=text.encode(),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=5
        )

        # Step 2: Activate target window if provided
        if window_id:
            result = subprocess.run(
                ['xdotool', 'windowactivate', '--sync', window_id],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode != 0:
                print(f"WARNING: Failed to activate window {window_id}: {result.stderr}", file=sys.stderr)

            # Small delay to ensure window is ready
            time.sleep(0.05)

        # Step 3: Send Shift+Insert to paste from clipboard
        # This is universal and works in terminals, Telegram, and most GUI apps
        result = subprocess.run(
            ['xdotool', 'key', '--clearmodifiers', 'shift+Insert'],
            capture_output=True,
            text=True,
            timeout=5
        )

        if result.returncode != 0:
            print(f"ERROR: Failed to send Shift+Insert: {result.stderr}", file=sys.stderr)
            return False

        return True

    except FileNotFoundError:
        print("ERROR: xclip or xdotool is not installed", file=sys.stderr)
        return False
    except Exception as e:
        print(f"ERROR: Clipboard paste failed: {e}", file=sys.stderr)
        return False


def main():
    # Get configuration from environment variables
    whisper_mode = os.environ.get('WHISPER_MODE', 'openai').lower()
    language = os.environ.get('WHISPER_LANGUAGE', 'auto')
    max_duration = int(os.environ.get('RECORDING_DURATION', '300'))
    openai_model = os.environ.get('OPENAI_MODEL', 'whisper-1')

    # Validate configuration
    if whisper_mode == 'openai':
        api_key = os.environ.get('OPENAI_API_KEY', '')
        if not api_key:
            print("ERROR: OPENAI_API_KEY is not set", file=sys.stderr)
            sys.exit(EXIT_CONFIG_ERROR)
    elif whisper_mode == 'local':
        server_url = os.environ.get('WHISPER_LOCAL_URL', '')
        if not server_url:
            print("ERROR: WHISPER_LOCAL_URL is not set", file=sys.stderr)
            sys.exit(EXIT_CONFIG_ERROR)
    else:
        print(f"ERROR: Unknown WHISPER_MODE: {whisper_mode}", file=sys.stderr)
        sys.exit(EXIT_CONFIG_ERROR)

    # Task 5.3: Capture initial active window ID
    initial_window_id = get_active_window()
    if not initial_window_id:
        print("WARNING: Could not get initial window ID, window tracking disabled", file=sys.stderr)

    # Create temporary file for audio (OGG/Opus format - streaming, always valid)
    temp_audio = tempfile.mktemp(suffix='.ogg', prefix='whisper-voice-')

    try:
        # Task 5.5: Record audio with user control and maximum duration
        success, reached_max = record_audio_user_controlled(max_duration, temp_audio)

        if not success:
            sys.exit(EXIT_RECORDING_ERROR)

        # Task 5.6: Exit with code 5 if maximum duration reached
        if reached_max:
            # Still transcribe the audio, but will notify applet
            print("Maximum recording duration reached", file=sys.stderr)

        # Step 2: Transcribe
        text = None

        if whisper_mode == 'openai':
            api_key = os.environ.get('OPENAI_API_KEY', '')
            # Use transcribe_openai for all models (whisper-1, gpt-4o-transcribe, etc.)
            text = transcribe_openai(temp_audio, api_key, language, openai_model)

        elif whisper_mode == 'local':
            server_url = os.environ.get('WHISPER_LOCAL_URL', 'http://localhost:9000/asr')
            text = transcribe_local(temp_audio, server_url, language)

        if not text:
            print("No text recognized", file=sys.stderr)
            sys.exit(EXIT_TRANSCRIPTION_ERROR)

        # Step 3: Paste text to original window
        print(f"Recognized: {text}", file=sys.stderr)

        # Paste text using clipboard + Shift+Insert method
        # This activates the original window before pasting
        if paste_text(text, initial_window_id):
            # Output the recognized text to stdout (for the applet)
            print(text, file=sys.stdout)

            if reached_max:
                sys.exit(EXIT_TIMEOUT)
            else:
                sys.exit(EXIT_SUCCESS)
        else:
            print("ERROR: paste_text() failed - text was not inserted", file=sys.stderr)
            sys.exit(EXIT_TRANSCRIPTION_ERROR)

    finally:
        # Cleanup temporary file
        if os.path.exists(temp_audio):
            try:
                os.remove(temp_audio)
            except:
                pass


if __name__ == '__main__':
    main()
